require('dotenv').config();

const http = require('http');
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const cookieParser = require('cookie-parser');
const { v4: uuidv4 } = require('uuid');

const Sentry = require('./services/sentry');
const logger = require('./services/logger');
require('./services/config');

const { initSockets } = require('./sockets');
const { env, port, corsOrigin } = require('./configs/env');

const discoveryRoutes = require('./routes/discovery');
const malwareRoutes = require('./routes/malwareRoutes');
const notifRouter = require('./routes/notifications');
const websitesRouter = require('./routes/websites');
const authRoutes = require('./routes/auth.routes');
const routes = require('./routes');
const sitesRouter = require('./routes/sites');

const csrfDoubleSubmit = require('./middleware/csrfDoubleSubmit');

const notFound = require('./middleware/notFound');
const errorHandler = require('./middleware/errorHandler');

const requestId = (req, res, next) => {
  req.id = req.id || uuidv4();
  res.setHeader('X-Request-ID', req.id);
  next();
};

let authLimiter;
try {
  authLimiter = require('./middleware/rateLimiter');
} catch (e) {
  const rateLimit = require('express-rate-limit');
  authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, 
    max: 20,
    message: { success: false, message: 'Too many attempts. Try again later.' },
  });
  logger.warn('Using fallback authLimiter');
}

const app = express();

logger.info('ENV JWT_SECRET (server) =', process.env.JWT_SECRET || '(not set)');

if (Sentry && Sentry.Handlers && typeof Sentry.Handlers.requestHandler === 'function') {
  app.use(Sentry.Handlers.requestHandler());
} else {
  logger.info('[Sentry] Disabled or DSN missing.');
}

app.use(
  helmet({
    contentSecurityPolicy: {
      useDefaults: true,
      directives: {
        "default-src": ["'self'"],
        "script-src": ["'self'"],
      },
    },
  })
);
app.use(helmet.hsts({ maxAge: 31536000, includeSubDomains: true, preload: true }));
app.disable('x-powered-by');

app.use(
  cors({
    origin: corsOrigin || process.env.CLIENT_ORIGIN || 'http://localhost:5173',
    credentials: true,
  })
);
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser());
app.use(requestId);

app.use('/api/auth', authLimiter, authRoutes);

app.use('/api', csrfDoubleSubmit);
app.use('/api/discovery', discoveryRoutes);
app.use('/api/malware', malwareRoutes);
app.use('/api/notifications', notifRouter);
app.use('/api/websites', websitesRouter);
app.use('/api/sites', sitesRouter);

app.use('/', routes);
app.post('/__test_body', (req, res) => {
  res.json({
    ok: true,
    body: req.body,
    headers: {
      authorization: req.headers.authorization || null,
      'content-type': req.headers['content-type'] || null,
    },
    requestId: req.id,
  });
})();
(function safeListRoutes(a) {
  if (!a || !a._router || !Array.isArray(a._router.stack)) {
    logger.info('DEBUG: app._router not ready yet â€” no routes to list.');
    return;
  }
  logger.info(' REGISTERED ROUTES ');
  a._router.stack.forEach((layer) => {
    if (layer.route && layer.route.path) {
      const methods = Object.keys(layer.route.methods).map((m) => m.toUpperCase()).join(',');
      logger.info(`${methods} ${layer.route.path}`);
      return;
    }
    if (layer.name === 'router' && layer.handle && layer.handle.stack) {
      layer.handle.stack.forEach((r) => {
        if (r.route && r.route.path) {
          const methods = Object.keys(r.route.methods).map((m) => m.toUpperCase()).join(',');
          logger.info(`${methods} ${r.route.path}`);
        }
      });
    }
  });
  logger.info(' END ROUTES ');
})(app);

app.use(notFound);

if (Sentry && Sentry.Handlers && typeof Sentry.Handlers.errorHandler === 'function') {
  app.use(Sentry.Handlers.errorHandler());
}
app.use(errorHandler);

const httpServer = http.createServer(app);
let io = null;
try {
  if (typeof initSockets === 'function') {
    io = initSockets(httpServer, { corsOrigin: process.env.CLIENT_ORIGIN || '*' });
    logger.info('Socket.IO initialized via backend/sockets');
  } else {
    logger.warn('initSockets not a function - skipping sockets init');
  }
} catch (err) {
  logger.warn('Could not initialize sockets (./sockets):', err && err.message ? err.message : err);
}

if (require.main === module) {
  httpServer.listen(PORT, () => {
    logger.info(`Server listening on ${PORT} (${env || process.env.NODE_ENV || 'unknown'} mode)`);
  });
}


process.on('unhandledRejection', (reason, p) => {
  logger.error('Unhandled Rejection at:', p, 'reason:', reason);
});
process.on('uncaughtException', (err) => {
  logger.error('Uncaught Exception:', err);
});

module.exports = { app, httpServer, io };
